<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Arrows 3D</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }

        body {
            background:
                radial-gradient(1200px 800px at 20% 30%, rgba(120, 180, 90, 0.85), rgba(30, 70, 35, 0.85) 55%, rgba(12, 30, 18, 0.95) 100%),
                radial-gradient(900px 700px at 80% 20%, rgba(90, 160, 80, 0.55), rgba(10, 25, 15, 0.0) 60%),
                radial-gradient(900px 700px at 70% 80%, rgba(70, 140, 75, 0.45), rgba(10, 25, 15, 0.0) 60%);
            position: relative;
        }

        body::before {
            content: "";
            position: absolute;
            inset: -40px;
            background:
                radial-gradient(18px 18px at 10% 15%, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0) 60%),
                radial-gradient(20px 20px at 35% 40%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0) 60%),
                radial-gradient(16px 16px at 65% 25%, rgba(255, 255, 255, 0.07), rgba(255, 255, 255, 0) 60%),
                radial-gradient(22px 22px at 80% 60%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0) 60%),
                radial-gradient(18px 18px at 20% 75%, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0) 60%);
            filter: blur(18px);
            opacity: 0.55;
            pointer-events: none;
        }

        #wrap {
            position: fixed;
            inset: 0;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        #hud {
            position: fixed;
            inset: 0;
            pointer-events: none;
        }

        #levelLabel {
            position: absolute;
            top: 14px;
            left: 50%;
            transform: translateX(-50%);
            color: #e9f0ff;
            font-weight: 700;
            letter-spacing: 0.5px;
            background: rgba(0, 0, 0, 0.25);
            padding: 8px 12px;
            border-radius: 12px;
            backdrop-filter: blur(6px);
        }

        #movesBox {
            position: absolute;
            top: 14px;
            left: 14px;
            color: #e9f0ff;
            font-weight: 800;
            background: rgba(0, 0, 0, 0.25);
            padding: 8px 12px;
            border-radius: 12px;
            display: none;
            backdrop-filter: blur(6px);
        }

        #movesBox.warn {
            color: #ffd2a6;
            animation: pulse 0.9s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.06);
            }
        }

        /* End card */
        #endCard {
            position: fixed;
            inset: 0;
            display: none;
            background: rgba(10, 40, 120, 0.92);
            color: #fff;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        #endCard.show {
            display: flex;
        }

        #card {
            width: min(520px, 92vw);
            background: rgba(59, 35, 4, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 18px;
            padding: 18px 18px 16px;
            box-shadow: 0 18px 60px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
            text-align: center;
        }

        #card h2 {
            margin: 6px 0 6px;
            font-size: 22px;
        }

        #card p {
            margin: 6px 0 14px;
            opacity: 0.95;
        }

        #bills {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 10px 0 16px;
        }

        .bill {
            width: 140px;
            height: 86px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.14);
            border: 1px solid rgba(255, 255, 255, 0.22);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 28px;
        }

        .bill.small {
            width: 110px;
            height: 70px;
            font-size: 24px;
            opacity: 0.95;
        }

        #btnRow {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        button {
            pointer-events: auto;
            border: 0;
            border-radius: 14px;
            padding: 12px 16px;
            font-weight: 800;
            min-width: 140px;
            cursor: pointer;
        }

        #homeBtn {
            background: rgba(255, 255, 255, 0.22);
            color: #fff;
        }

        #playBtn {
            background: #ffffff;
            color: #0a2a78;
        }

        #hint {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(233, 240, 255, 0.75);
            font-size: 12px;
            background: rgba(0, 0, 0, 0.18);
            padding: 6px 10px;
            border-radius: 999px;
            backdrop-filter: blur(6px);
        }
    </style>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>

<body>
    <div id="wrap"></div>

    <div id="hud">
        <div id="levelLabel">Level</div>
        <div id="movesBox">Moves: <span id="movesVal">30</span></div>
        <div id="hint">Drag to rotate • Tap exposed blocks to remove • Two-finger twist (or Shift+drag) to roll</div>
    </div>

    <div id="endCard">
        <div id="card">
            <h2 id="endTitle">Level</h2>
            <p id="endMsg">You win</p>
            <div id="bills">
                <div class="bill">$20</div>
                <div class="bill small">$1</div>
            </div>
            <div id="btnRow">
                <button id="homeBtn">Home</button>
                <button id="playBtn">Play</button>
            </div>
        </div>
    </div>

    <script>
        (function () {
            if (!window.THREE) {
                const msg = document.createElement('div');
                msg.style.position = 'fixed';
                msg.style.inset = '0';
                msg.style.display = 'flex';
                msg.style.alignItems = 'center';
                msg.style.justifyContent = 'center';
                msg.style.padding = '24px';
                msg.style.color = '#fff';
                msg.style.background = '#0b0f1a';
                msg.style.fontFamily = 'system-ui, sans-serif';
                msg.innerHTML = '<div style="max-width:760px; line-height:1.35;"><h2 style="margin:0 0 10px;">Three.js failed to load</h2><p style="margin:0 0 10px;">This playable requires Three.js. Ensure the CDN is reachable or embed Three.js inline for production.</p></div>';
                document.body.appendChild(msg);
            }
        })();
    </script>

    <script>
        (function () {
            if (!window.THREE) return;

            const DEBUG = new URLSearchParams(location.search).get('debug') === '1';

            const DIRS = ['+X', '-X', '+Y', '-Y', '+Z', '-Z'];
            const levelConfigs = [
                {
                    labelTopCenter: 'Level 2-2',
                    endCardTitle: 'Level 2-2',
                    endCardMessageWin: 'You win',
                    arrows: [
                        '+Z', '+Z', '+Z', '+Y', '+Y', '+Y', '-Z', '-Z', '-Z',
                        '+X', '+X', '+X', '+Z', '-X', '-Z', '-X', '-X', '-X',
                        '+Z', '+Z', '+Z', '-Y', '-Y', '-Y', '-Z', '-Z', '-Z'
                    ]

                },
                {
                    labelTopCenter: 'Level 2-3',
                    endCardTitle: 'Level 2-3',
                    endCardMessageWin: 'You did it! Get stronger in the full game.',
                    endCardMessageExceeded: 'You win',
                    movesLimit: 30,
                    arrows: [
                        '+X', '+Y', '+Y',
                        '-Z', '+Z', '+Y',
                        '-Z', '+Y', '+X',

                        '+Z', '+X', '+Z',
                        '-Z', '+X', '+X',
                        '-Z', '-X', '-X',
                        '+Z', '+X', '+Z',
                        '-Y', '-Y', '+Y',
                        '+X', '-Y', '-Z',

                    ]
                }
            ];
            window.levelConfigs = levelConfigs;

            function validateLevelConfig(cfg, idx) {
                const issues = [];
                if (!cfg.arrows || cfg.arrows.length !== 27) issues.push('Level ' + idx + ': arrows length must be 27');
                if (cfg.arrows) cfg.arrows.forEach((d, i) => { if (!DIRS.includes(d)) issues.push('Level ' + idx + ': invalid dir at ' + i + ': ' + d); });
                if (DEBUG) {
                    const dist = { '+X': 0, '-X': 0, '+Y': 0, '-Y': 0, '+Z': 0, '-Z': 0 };
                    (cfg.arrows || []).forEach(d => { if (dist[d] != null) dist[d]++; });
                    console.log('Level', idx, 'dir distribution', dist);
                }
                if (issues.length && DEBUG) console.warn(issues.join('\n'));
                return issues.length === 0;
            }
            levelConfigs.forEach(validateLevelConfig);

            const AudioSystem = (() => {
                let ctx, bg, swipeBuf, bgGain, sfxGain;
                let unlocked = false;
                let lastInvalidAt = 0;

                async function unlock() {
                    if (unlocked) return;
                    try {
                        ctx = new (window.AudioContext || window.webkitAudioContext)();
                        bgGain = ctx.createGain(); bgGain.gain.value = 0.18; bgGain.connect(ctx.destination);
                        sfxGain = ctx.createGain(); sfxGain.gain.value = 1.0; sfxGain.connect(ctx.destination);

                        const [bgBuf, swipe] = await Promise.all([
                            fetch('../assets/sounds/bg.mp3').then(r => r.arrayBuffer()).then(b => ctx.decodeAudioData(b)),
                            fetch('../assets/sounds/swipe.mp3').then(r => r.arrayBuffer()).then(b => ctx.decodeAudioData(b)),
                        ]);
                        swipeBuf = swipe;

                        bg = ctx.createBufferSource();
                        bg.buffer = bgBuf;
                        bg.loop = true;
                        bg.connect(bgGain);
                        bg.start(0);

                        unlocked = true;
                    } catch (e) {
                        if (DEBUG) console.warn('Audio init failed', e);
                        unlocked = true;
                    }
                }

                function playSwipe(valid) {
                    if (!ctx || !swipeBuf) return;
                    const now = performance.now();
                    if (!valid && now - lastInvalidAt < 120) return;
                    if (!valid) lastInvalidAt = now;

                    const src = ctx.createBufferSource();
                    src.buffer = swipeBuf;
                    const g = ctx.createGain();
                    g.gain.value = valid ? 0.35 : 0.22;
                    src.connect(g); g.connect(sfxGain);
                    src.start(0);
                }

                return { unlock, playSwipe };
            })();

            class GridModel {
                constructor() {
                    this.cells = [];
                    this.map = new Map();
                }
                static idxFromXYZ(x, y, z) { return (z + 1) * 9 + (y + 1) * 3 + (x + 1); }
                static key(x, y, z) { return x + ',' + y + ',' + z; }
                inBounds(x, y, z) { return x >= -1 && x <= 1 && y >= -1 && y <= 1 && z >= -1 && z <= 1; }
                get(x, y, z) { return this.map.get(GridModel.key(x, y, z)); }

                buildFromArrows(arrows) {
                    this.cells.length = 0;
                    this.map.clear();
                    for (let z = -1; z <= 1; z++) {
                        for (let y = -1; y <= 1; y++) {
                            for (let x = -1; x <= 1; x++) {
                                const id = GridModel.idxFromXYZ(x, y, z);
                                const dir = arrows[id];
                                const cell = { id, pos: { x, y, z }, dir, active: true, exposed: false };
                                this.cells.push(cell);
                                this.map.set(GridModel.key(x, y, z), cell);
                            }
                        }
                    }
                    this.recomputeExposed();
                }

                activeCount() {
                    let c = 0;
                    for (const cell of this.cells) if (cell.active) c++;
                    return c;
                }

                recomputeExposed() {
                    const neigh = [[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]];
                    for (const cell of this.cells) {
                        if (!cell.active) { cell.exposed = false; continue; }
                        let exp = false;
                        for (const n of neigh) {
                            const nx = cell.pos.x + n[0], ny = cell.pos.y + n[1], nz = cell.pos.z + n[2];
                            if (!this.inBounds(nx, ny, nz)) { exp = true; break; }
                            const c = this.get(nx, ny, nz);
                            if (!c || !c.active) { exp = true; break; }
                        }
                        cell.exposed = exp;
                    }
                }

                dirToVec(dir) {
                    switch (dir) {
                        case '+X': return { dx: 1, dy: 0, dz: 0 };
                        case '-X': return { dx: -1, dy: 0, dz: 0 };
                        case '+Y': return { dx: 0, dy: 1, dz: 0 };
                        case '-Y': return { dx: 0, dy: -1, dz: 0 };
                        case '+Z': return { dx: 0, dy: 0, dz: 1 };
                        case '-Z': return { dx: 0, dy: 0, dz: -1 };
                    }
                    return { dx: 0, dy: 0, dz: 0 };
                }

                clearPath(cell) {
                    const v = this.dirToVec(cell.dir);
                    let x = cell.pos.x + v.dx, y = cell.pos.y + v.dy, z = cell.pos.z + v.dz;
                    while (this.inBounds(x, y, z)) {
                        const c = this.get(x, y, z);
                        if (c && c.active) return false;
                        x += v.dx; y += v.dy; z += v.dz;
                    }
                    return true;
                }

                firstBlocker(cell) {
                    const v = this.dirToVec(cell.dir);
                    let x = cell.pos.x + v.dx, y = cell.pos.y + v.dy, z = cell.pos.z + v.dz;
                    while (this.inBounds(x, y, z)) {
                        const c = this.get(x, y, z);
                        if (c && c.active) return c;
                        x += v.dx; y += v.dy; z += v.dz;
                    }
                    return null;
                }

                hasAnyValidMove() {
                    for (const cell of this.cells) {
                        if (!cell.active || !cell.exposed) continue;
                        if (this.clearPath(cell)) return true;
                    }
                    return false;
                }
            }

            class TweenSystem {
                constructor() { this.tweens = new Set(); }
                add(t) { this.tweens.add(t); return t; }
                killByTag(tag) { for (const t of [...this.tweens]) if (t.tag === tag) this.tweens.delete(t); }
                clearAll() { this.tweens.clear(); }
                update(dt) {
                    for (const t of [...this.tweens]) {
                        t.t += dt;
                        const p = Math.min(1, t.t / t.d);
                        const e = t.ease ? t.ease(p) : p;
                        t.step(e, p);
                        if (p >= 1) {
                            if (t.done) t.done();
                            this.tweens.delete(t);
                        }
                    }
                }
            }
            const easeOutCubic = p => 1 - Math.pow(1 - p, 3);
            const easeInOutQuad = p => p < 0.5 ? 2 * p * p : 1 - Math.pow(-2 * p + 2, 2) / 2;

            class RenderSystem {
                constructor(scene, cubeRoot, model, tweens) {
                    this.scene = scene;
                    this.cubeRoot = cubeRoot;
                    this.model = model;
                    this.tweens = tweens;

                    this.blockById = new Map();
                    this.pickables = [];
                    this.raycaster = new THREE.Raycaster();

                    this.blockSize = 0.92;
                    this.gap = 0.06;
                    this.spacing = this.blockSize + this.gap;

                    this.arrowTex = this.makeArrowTexture();
                    this.sharedGeo = new THREE.BoxGeometry(this.blockSize, this.blockSize, this.blockSize);
                    this.sharedArrowGeo = new THREE.PlaneGeometry(this.blockSize * 0.62, this.blockSize * 0.62);

                    this.woodMats = [
                        new THREE.MeshStandardMaterial({ color: 0xb98a5a, roughness: 0.85, metalness: 0.15, transparent: true, opacity: 0.9 }),
                        new THREE.MeshStandardMaterial({ color: 0xc79a66, roughness: 0.82, metalness: 0.15, transparent: true, opacity: 0.9 }),
                        new THREE.MeshStandardMaterial({ color: 0xa97a4f, roughness: 0.88, metalness: 0.15, transparent: true, opacity: 0.9 })
                    ];

                    this.arrowMat = new THREE.MeshBasicMaterial({
                        map: this.arrowTex,
                        transparent: true,
                        opacity: 1,      // faint inner arrows
                        depthTest: true,    // let blocks occlude arrows
                        depthWrite: true,   // so arrows don’t overwrite depth
                        polygonOffset: true,
                        polygonOffsetFactor: -1,
                        polygonOffsetUnits: -1
                    });
                }

                reset() {
                    this.tweens.clearAll();

                    for (const g of this.blockById.values()) {
                        if (g && g.parent) g.parent.remove(g);
                    }
                    this.blockById.clear();
                    this.pickables.length = 0;

                    const toRemove = [];
                    this.scene.traverse(obj => {
                        if (obj && obj.userData && obj.userData.cellId != null && obj.type === 'Group') {
                            if (obj.children && obj.children[0] && obj.children[0].isMesh) toRemove.push(obj);
                        }
                    });
                    for (const obj of toRemove) if (obj.parent) obj.parent.remove(obj);
                }

                makeArrowTexture() {
                    const c = document.createElement('canvas');
                    c.width = 256; c.height = 256;
                    const g = c.getContext('2d');
                    g.clearRect(0, 0, 256, 256);
                    g.translate(128, 128);
                    g.fillStyle = 'rgba(255,255,255,0.95)';
                    g.beginPath();
                    g.moveTo(0, -92);
                    g.lineTo(44, -20);
                    g.lineTo(18, -20);
                    g.lineTo(18, 92);
                    g.lineTo(-18, 92);
                    g.lineTo(-18, -20);
                    g.lineTo(-44, -20);
                    g.closePath();
                    g.fill();
                    const tex = new THREE.CanvasTexture(c);
                    tex.anisotropy = 4;
                    tex.needsUpdate = true;
                    return tex;
                }

                dirToNormal(dir) {
                    switch (dir) {
                        case '+X': return new THREE.Vector3(1, 0, 0);
                        case '-X': return new THREE.Vector3(-1, 0, 0);
                        case '+Y': return new THREE.Vector3(0, 1, 0);
                        case '-Y': return new THREE.Vector3(0, -1, 0);
                        case '+Z': return new THREE.Vector3(0, 0, 1);
                        case '-Z': return new THREE.Vector3(0, 0, -1);
                    }
                    return new THREE.Vector3(0, 0, 1);
                }

                faceNormalsForDir(dir) {
                    switch (dir) {
                        case '+X':
                        case '-X':
                            return [new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)];
                        case '+Y':
                        case '-Y':
                            return [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)];
                        case '+Z':
                        case '-Z':
                            return [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)];
                    }
                    return [];
                }

                makeArrowOnFace(faceNormal, flyLocalDir) {
                    const arrow = new THREE.Mesh(this.sharedArrowGeo, this.arrowMat.clone());
                    arrow.renderOrder = 10;

                    const faceOffset = (this.blockSize / 2) + 0.004;
                    arrow.position.copy(faceNormal.clone().multiplyScalar(faceOffset));

                    const qFace = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), faceNormal);
                    arrow.quaternion.copy(qFace);

                    const projected = flyLocalDir.clone().projectOnPlane(faceNormal);
                    if (projected.lengthSq() < 1e-6) return arrow;
                    projected.normalize();

                    const worldUpOnPlane = new THREE.Vector3(0, 1, 0).applyQuaternion(arrow.quaternion).normalize();
                    const cross = new THREE.Vector3().crossVectors(worldUpOnPlane, projected);
                    const sign = Math.sign(cross.dot(faceNormal)) || 1;
                    const dot = THREE.MathUtils.clamp(worldUpOnPlane.dot(projected), -1, 1);
                    const angle = Math.acos(dot) * sign;

                    const qSpin = new THREE.Quaternion().setFromAxisAngle(faceNormal, angle);
                    arrow.quaternion.premultiply(qSpin);

                    return arrow;
                }

                build() {
                    for (const g of this.blockById.values()) if (g.parent) g.parent.remove(g);
                    this.blockById.clear();

                    for (const cell of this.model.cells) {
                        const group = new THREE.Group();
                        group.userData.cellId = cell.id;
                        group.userData.detaching = false;

                        const mat = this.woodMats[cell.id % this.woodMats.length];
                        const box = new THREE.Mesh(this.sharedGeo, mat);
                        box.castShadow = true;
                        box.receiveShadow = true;
                        box.userData.cellId = cell.id;
                        group.add(box);

                        const flyLocal = this.dirToNormal(cell.dir).clone().normalize();
                        const faces = this.faceNormalsForDir(cell.dir);
                        for (const fn of faces) group.add(this.makeArrowOnFace(fn, flyLocal));

                        const basePos = new THREE.Vector3(cell.pos.x * this.spacing, cell.pos.y * this.spacing, cell.pos.z * this.spacing);
                        group.userData.basePos = basePos.clone();
                        group.position.copy(basePos);

                        this.cubeRoot.add(group);
                        this.blockById.set(cell.id, group);
                    }
                    this.syncRenderAndPickables();
                }

                syncRenderAndPickables() {
                    this.pickables.length = 0;
                    for (const cell of this.model.cells) {
                        const g = this.blockById.get(cell.id);
                        if (!g) continue;

                        if (!g.userData.detaching) g.visible = !!cell.active;
                        else g.visible = true;

                        if (cell.active && cell.exposed && !g.userData.detaching) this.pickables.push(g.children[0]);

                        const box = g.children[0];
                        if (!box.material.emissive) box.material.emissive = new THREE.Color(0x000000);
                        box.material.emissiveIntensity = cell.exposed ? 0.12 : 0.02;
                    }
                }

                worldDirForCell(cell) {
                    const local = this.dirToNormal(cell.dir).clone().normalize();
                    return local.applyQuaternion(this.cubeRoot.quaternion).normalize();
                }

                detach(cell) {
                    const g = this.blockById.get(cell.id);
                    if (!g) return;

                    this.tweens.killByTag('clap_' + cell.id);
                    this.tweens.killByTag('detach_' + cell.id);

                    g.userData.detaching = true;

                    const worldPos = new THREE.Vector3();
                    const worldQuat = new THREE.Quaternion();
                    const worldScale = new THREE.Vector3();
                    g.updateMatrixWorld(true);
                    g.matrixWorld.decompose(worldPos, worldQuat, worldScale);

                    this.cubeRoot.remove(g);
                    this.scene.add(g);
                    g.position.copy(worldPos);
                    g.quaternion.copy(worldQuat);
                    g.scale.copy(worldScale);

                    const dirW = this.worldDirForCell(cell);
                    const startPos = g.position.clone();
                    const endPos = startPos.clone().add(dirW.multiplyScalar(3.2));
                    const startQ = g.quaternion.clone();
                    const spinAxis = new THREE.Vector3(0.6, 0.8, 0.2).normalize();
                    const spinQ = new THREE.Quaternion().setFromAxisAngle(spinAxis, Math.PI * 1.2);

                    const box = g.children[0];
                    box.material = box.material.clone();
                    box.material.transparent = true;

                    for (let i = 1; i < g.children.length; i++) {
                        const ch = g.children[i];
                        ch.material = ch.material.clone();
                        ch.material.transparent = true;
                        ch.material.depthTest = false;
                        ch.material.depthWrite = false;
                    }

                    this.tweens.add({
                        tag: 'detach_' + cell.id,
                        t: 0, d: 0.45,
                        ease: easeOutCubic,
                        step: (e) => {
                            g.position.lerpVectors(startPos, endPos, e);
                            g.quaternion.copy(startQ).slerp(startQ.clone().multiply(spinQ), e);
                            const a = 1 - e;
                            box.material.opacity = a;
                            for (let i = 1; i < g.children.length; i++) g.children[i].material.opacity = a;
                        },
                        done: () => {
                            if (g.parent) g.parent.remove(g);
                            this.blockById.delete(cell.id);
                        }
                    });
                }

                clapBack(cell, blocked, blockerCell) {
                    const g = this.blockById.get(cell.id);
                    if (!g) return;

                    this.tweens.killByTag('clap_' + cell.id);

                    const base = g.userData.basePos.clone();
                    const kick = 0.18;

                    let localDir = this.dirToNormal(cell.dir).clone().normalize();
                    if (blockerCell) {
                        const b = new THREE.Vector3(blockerCell.pos.x * this.spacing, blockerCell.pos.y * this.spacing, blockerCell.pos.z * this.spacing);
                        const v = b.clone().sub(base);
                        if (v.lengthSq() > 1e-6) localDir = v.normalize();
                    }

                    const box = g.children[0];
                    const origEm = box.material.emissiveIntensity || 0.05;

                    this.tweens.add({
                        tag: 'clap_' + cell.id,
                        t: 0, d: 0.22,
                        ease: easeInOutQuad,
                        step: (e, p) => {
                            const out = p < 0.5 ? (p / 0.5) : (1 - (p - 0.5) / 0.5);
                            const off = kick * out;
                            g.position.copy(base).add(localDir.clone().multiplyScalar(off));
                            if (blocked) box.material.emissiveIntensity = origEm + 0.25 * out;
                        },
                        done: () => {
                            g.position.copy(base);
                            box.material.emissiveIntensity = origEm;
                        }
                    });
                }
            }

            class InputSystem {
                constructor(dom, camera, cubeRoot, renderSystem, model, onTapCell) {
                    this.dom = dom;
                    this.camera = camera;
                    this.cubeRoot = cubeRoot;
                    this.renderSystem = renderSystem;
                    this.model = model;
                    this.onTapCell = onTapCell;

                    this.pointerDown = false;
                    this.dragging = false;
                    this.startX = 0; this.startY = 0;
                    this.lastX = 0; this.lastY = 0;
                    this.tapThreshold = 8;

                    this.vel = new THREE.Vector3(0, 0, 0);
                    this.inertiaK = 6.5;

                    this.touches = new Map();
                    this.lastTwistAngle = null;
                    this.shiftRoll = false;

                    this.ndc = new THREE.Vector2();

                    this.bind();
                }

                bind() {
                    window.addEventListener('keydown', (e) => { if (e.key === 'Shift') this.shiftRoll = true; });
                    window.addEventListener('keyup', (e) => { if (e.key === 'Shift') this.shiftRoll = false; });

                    this.dom.addEventListener('pointerdown', (e) => this.onDown(e), { passive: false });
                    this.dom.addEventListener('pointermove', (e) => this.onMove(e), { passive: false });
                    this.dom.addEventListener('pointerup', (e) => this.onUp(e), { passive: false });
                    this.dom.addEventListener('pointercancel', (e) => this.onUp(e), { passive: false });

                    this.dom.addEventListener('touchstart', () => { }, { passive: true });
                }

                onDown(e) {
                    e.preventDefault();
                    AudioSystem.unlock();

                    this.dom.setPointerCapture && this.dom.setPointerCapture(e.pointerId);
                    this.pointerDown = true;
                    this.dragging = false;
                    this.startX = this.lastX = e.clientX;
                    this.startY = this.lastY = e.clientY;

                    this.touches.set(e.pointerId, { x: e.clientX, y: e.clientY });
                    if (this.touches.size === 2) {
                        const pts = [...this.touches.values()];
                        this.lastTwistAngle = Math.atan2(pts[1].y - pts[0].y, pts[1].x - pts[0].x);
                    }
                }

                onMove(e) {
                    if (!this.pointerDown) return;
                    e.preventDefault();

                    const dx = e.clientX - this.lastX;
                    const dy = e.clientY - this.lastY;

                    this.touches.set(e.pointerId, { x: e.clientX, y: e.clientY });

                    const totalDx = e.clientX - this.startX;
                    const totalDy = e.clientY - this.startY;
                    if (!this.dragging && Math.hypot(totalDx, totalDy) > this.tapThreshold) this.dragging = true;

                    const rotScale = 0.0065;

                    if (this.touches.size === 2) {
                        const pts = [...this.touches.values()];
                        const ang = Math.atan2(pts[1].y - pts[0].y, pts[1].x - pts[0].x);
                        if (this.lastTwistAngle != null) {
                            const dAng = ang - this.lastTwistAngle;
                            this.applyWorldRotation(0, 0, dAng);
                            this.vel.set(0, 0, dAng / 0.016);
                        }
                        this.lastTwistAngle = ang;
                    } else {
                        if (this.shiftRoll) {
                            const roll = dx * rotScale;
                            this.applyWorldRotation(0, 0, roll);
                            this.vel.set(0, 0, roll / 0.016);
                        } else {
                            const yaw = dx * rotScale;
                            const pitch = dy * rotScale;
                            this.applyWorldRotation(pitch, yaw, 0);
                            this.vel.set(pitch / 0.016, yaw / 0.016, 0);
                        }
                    }

                    this.lastX = e.clientX;
                    this.lastY = e.clientY;
                }

                onUp(e) {
                    e.preventDefault();
                    this.touches.delete(e.pointerId);
                    if (this.touches.size < 2) this.lastTwistAngle = null;

                    const wasDragging = this.dragging;
                    this.pointerDown = false;

                    if (!wasDragging) this.tryTap(e.clientX, e.clientY);
                }

                applyWorldRotation(rx, ry, rz) {
                    const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), rx);
                    const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), ry);
                    const qz = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), rz);
                    this.cubeRoot.quaternion.premultiply(qz).premultiply(qy).premultiply(qx);
                }

                tryTap(clientX, clientY) {
                    const rect = this.dom.getBoundingClientRect();
                    this.ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                    this.ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

                    this.renderSystem.raycaster.setFromCamera(this.ndc, this.camera);
                    const hits = this.renderSystem.raycaster.intersectObjects(this.renderSystem.pickables, false);
                    if (!hits.length) return;

                    const id = hits[0].object.userData.cellId;
                    const cell = this.model.cells.find(c => c.id === id);
                    if (cell) this.onTapCell(cell);
                }

                update(dt) {
                    if (this.pointerDown) return;
                    const decay = Math.exp(-this.inertiaK * dt);
                    this.vel.multiplyScalar(decay);

                    const rx = this.vel.x * dt;
                    const ry = this.vel.y * dt;
                    const rz = this.vel.z * dt;
                    if (Math.abs(rx) + Math.abs(ry) + Math.abs(rz) > 1e-5) this.applyWorldRotation(rx, ry, rz);
                }
            }

            const UI = (() => {
                const levelLabel = document.getElementById('levelLabel');
                const movesBox = document.getElementById('movesBox');
                const movesVal = document.getElementById('movesVal');

                const endCard = document.getElementById('endCard');
                const endTitle = document.getElementById('endTitle');
                const endMsg = document.getElementById('endMsg');
                const homeBtn = document.getElementById('homeBtn');
                const playBtn = document.getElementById('playBtn');

                function setLevelLabel(t) { levelLabel.textContent = t; }
                function setMovesVisible(v) { movesBox.style.display = v ? 'block' : 'none'; }
                function setMoves(n) {
                    movesVal.textContent = String(Math.max(0, n));
                    movesBox.classList.toggle('warn', n <= 5);
                }
                function showEndCard(title, msg) {
                    endTitle.textContent = title;
                    endMsg.textContent = msg;
                    endCard.classList.add('show');
                }
                function hideEndCard() { endCard.classList.remove('show'); }

                return { setLevelLabel, setMovesVisible, setMoves, showEndCard, hideEndCard, homeBtn, playBtn };
            })();

            const State = { BOOT: 0, PLAYING: 1, WIN_TRANSITION: 2, WIN_SCREEN: 3, PAUSED_END: 4, GAME_OVER: 5 };

            class App {
                constructor() {
                    this.state = State.BOOT;
                    this.levelIndex = 0;

                    this.model = new GridModel();
                    this.tweens = new TweenSystem();

                    this.playableStartMs = performance.now();
                    this.playableEnded = false;

                    this.movesUsed = 0;

                    this.initThree();
                    this.renderSystem = new RenderSystem(this.scene, this.cubeRoot, this.model, this.tweens);

                    this.input = new InputSystem(
                        this.renderer.domElement,
                        this.camera,
                        this.cubeRoot,
                        this.renderSystem,
                        this.model,
                        (cell) => this.handleTap(cell)
                    );

                    UI.homeBtn.addEventListener('click', () => this.goHome());
                    UI.playBtn.addEventListener('click', () => this.playOrClickout());

                    window.addEventListener('resize', () => this.onResize());
                    this.onResize();

                    this.loadLevel(0);
                    this.state = State.PLAYING;

                    this.lastT = performance.now();
                    requestAnimationFrame(() => this.loop());
                }

                initThree() {
                    const wrap = document.getElementById('wrap');

                    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                    this.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    //   this.renderer.setClearColor(0x0b0f1a, 1);
                    this.renderer.shadowMap.enabled = true;
                    wrap.appendChild(this.renderer.domElement);

                    this.scene = new THREE.Scene();

                    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
                    this.camera.position.set(0, 0.2, 8.2);

                    const amb = new THREE.AmbientLight(0xffffff, 0.55);
                    this.scene.add(amb);

                    const dir = new THREE.DirectionalLight(0xffffff, 1.05);
                    dir.position.set(4, 6, 7);
                    dir.castShadow = true;
                    dir.shadow.mapSize.set(1024, 1024);
                    this.scene.add(dir);

                    const rim = new THREE.DirectionalLight(0x8fb6ff, 0.45);
                    rim.position.set(-6, 2, -5);
                    this.scene.add(rim);

                    const floor = new THREE.Mesh(
                        new THREE.PlaneGeometry(40, 40),
                        new THREE.MeshStandardMaterial({ color: 0x258B35, transparent: true, opacity: 0.50 })
                    );
                    floor.rotation.x = -Math.PI / 2;
                    floor.position.y = -3.2;
                    floor.receiveShadow = true;
                    this.scene.add(floor);

                    this.cubeRoot = new THREE.Group();
                    this.scene.add(this.cubeRoot);

                    this.cubeRoot.rotation.set(0.55, 0.65, 0.0);
                }

                onResize() {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);

                    const minDim = Math.min(window.innerWidth, window.innerHeight);
                    const isSmall = minDim < 520;
                    this.camera.position.z = isSmall ? 10.2 : 8.2;
                    const scale = isSmall ? 0.8 : 1.0;
                    this.cubeRoot.scale.set(scale, scale, scale);
                }

                loadLevel(i) {
                    this.levelIndex = (i + levelConfigs.length) % levelConfigs.length;
                    const cfg = levelConfigs[this.levelIndex];
                    validateLevelConfig(cfg, this.levelIndex);

                    UI.hideEndCard();
                    UI.setLevelLabel(cfg.labelTopCenter);

                    this.movesUsed = 0;

                    this.renderSystem.reset();

                    this.model.buildFromArrows(cfg.arrows);
                    this.renderSystem.build();

                    // Hard guarantee: never start a level with zero valid moves
                    if (!this.model.hasAnyValidMove()) {
                        const safe = [
                            '-Z', '-Z', '-Z', '-Z', '-Z', '-Z', '-Z', '-Z', '-Z',
                            '-X', '-Y', '+X', '-X', '+Y', '+X', '-X', '-Y', '+X',
                            '+Z', '+Z', '+Z', '+Z', '+Z', '+Z', '+Z', '+Z', '+Z'
                        ];
                        this.model.buildFromArrows(safe);
                        this.renderSystem.reset();
                        this.renderSystem.build();
                    }

                    const hasMoves = cfg.movesLimit != null;
                    UI.setMovesVisible(!!hasMoves);
                    if (hasMoves) UI.setMoves(cfg.movesLimit);

                    this.state = State.PLAYING;
                }

                onDeadlock() {
                    this.loadLevel(this.levelIndex);
                }

                handleTap(cell) {
                    if (this.state !== State.PLAYING) return;
                    if (!cell.active || !cell.exposed) return;

                    const cfg = levelConfigs[this.levelIndex];

                    if (cfg.movesLimit != null) {
                        this.movesUsed++;
                        UI.setMoves(cfg.movesLimit - this.movesUsed);
                    }

                    const ok = this.model.clearPath(cell);
                    if (DEBUG) console.log('tap', { id: cell.id, pos: cell.pos, dir: cell.dir, exposed: cell.exposed, clearPath: ok });

                    if (ok) {
                        AudioSystem.playSwipe(true);

                        this.renderSystem.detach(cell);
                        cell.active = false;
                        this.model.recomputeExposed();
                        this.renderSystem.syncRenderAndPickables();

                        if (this.model.activeCount() === 0) {
                            this.win();
                            return;
                        }
                        if (cfg.movesLimit != null && this.movesUsed >= cfg.movesLimit) {
                            this.gameOver();
                            return;
                        }
                        if (!this.model.hasAnyValidMove()) this.onDeadlock();
                    } else {
                        AudioSystem.playSwipe(false);
                        const blocker = this.model.firstBlocker(cell);
                        this.renderSystem.clapBack(cell, true, blocker);
                    }
                    if (cfg.movesLimit != null && this.movesUsed >= cfg.movesLimit) this.gameOver();
                }

                win() {
                    this.state = State.WIN_SCREEN;
                    const cfg = levelConfigs[this.levelIndex];

                    let msg = cfg.endCardMessageWin || 'You win';
                    if (cfg.movesLimit != null && this.movesUsed >= cfg.movesLimit) msg = cfg.endCardMessageExceeded || msg;
                    if (cfg.labelTopCenter === 'Level 2-3') {
                        this.endPlayable();
                    } else {
                        UI.homeBtn.textContent = 'Home';
                        UI.playBtn.textContent = 'Play';
                        UI.showEndCard(cfg.endCardTitle || 'Level', msg);
                    }
                }

                gameOver() {
                    this.state = State.GAME_OVER;
                    UI.homeBtn.textContent = 'Home';
                    UI.playBtn.textContent = 'Retry';
                    UI.showEndCard('Game Over', 'Out of moves. Try again!');
                }

                endPlayable() {
                    if (this.playableEnded) return;
                    this.playableEnded = true;
                    this.state = State.PAUSED_END;

                    UI.homeBtn.textContent = 'Replay';
                    UI.playBtn.textContent = 'Download';
                    UI.showEndCard('Download Our Game - Arrows 3d!', 'Thanks for playing!');
                }

                goHome() {
                    if (this.state === State.PAUSED_END) {
                        UI.homeBtn.textContent = 'Home';
                        UI.playBtn.textContent = 'Play';
                        this.playableStartMs = performance.now();
                        this.playableEnded = false;
                        this.loadLevel(0);
                        return;
                    }
                    if (this.state === State.GAME_OVER) {
                        this.loadLevel(0);
                        return;
                    }
                    this.loadLevel(0);
                }

                playOrClickout() {
                    if (this.state === State.GAME_OVER) {
                        this.loadLevel(this.levelIndex);
                        return;
                    }
                    const clickTag = window.clickTag || window.ClickTag;
                    const mraid = window.mraid;

                    try {
                        if (mraid && typeof mraid.open === 'function') {
                            mraid.open(clickTag || 'https://example.com');
                            return;
                        }
                        if (clickTag) {
                            window.open(clickTag, '_blank');
                            return;
                        }
                    } catch (e) { }

                    this.loadLevel(this.levelIndex + 1);
                }

                loop() {
                    const now = performance.now();
                    const dt = Math.min(0.033, (now - this.lastT) / 1000);
                    this.lastT = now;

                    if (!this.playableEnded && (now - this.playableStartMs) >= 60000) this.endPlayable();

                    if (this.state === State.PLAYING) {
                        this.input.update(dt);
                        this.tweens.update(dt);
                    }

                    this.renderer.render(this.scene, this.camera);
                    requestAnimationFrame(() => this.loop());
                }
            }

            new App();
        })();
    </script>
</body>

</html>