<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Banana Dash 3D ğŸŒ</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#000; overflow:hidden; font-family:'Press Start 2P',monospace; }
  #c { display:block; width:100vw; height:100vh; }

#ui {
position:fixed; top:0; left:0; right:0;
display:flex; justify-content:space-between; align-items:flex-start;
padding:14px 22px; pointer-events:none; z-index:10;
}
.ui-box {
background:#0009; border:2px solid #ffe94e88;
border-radius:4px; padding:7px 12px; color:#fff; font-size:8px; line-height:2.2;
}
.val { color:#ffe94e; font-size:10px; }
#hearts { font-size:13px; letter-spacing:2px; }

/* Powerup indicators */
#powerups {
position:fixed; bottom:18px; left:50%; transform:translateX(-50%);
display:flex; gap:12px; pointer-events:none; z-index:10;
}
.pu-pill {
background:#0009; border:2px solid #fff4; border-radius:20px;
padding:5px 12px; color:#fff; font-size:8px;
display:flex; align-items:center; gap:6px;
transition:opacity 0.3s;
}
.pu-pill.active { border-color:#ffe94e; box-shadow:0 0 12px #ffe94e88; }
.pu-bar { width:50px; height:5px; background:#333; border-radius:3px; overflow:hidden; }
.pu-fill { height:100%; border-radius:3px; transition:width 0.1s; }

/* Overlay */
#overlay {
position:fixed; inset:0;
display:flex; flex-direction:column; align-items:center; justify-content:center;
background:#000a; z-index:20; gap:18px;
}
#overlay.hidden { display:none; }
.ov-title { color:#ffe94e; font-size:26px; text-shadow:4px 4px #c47800,0 0 30px #ffe94eaa; text-align:center; }
.ov-sub { color:#fff; font-size:9px; line-height:2.4; text-align:center; }
.blink { animation:blink 1s step-end infinite; }
@keyframes blink { 50%{opacity:0;} }

/* Screen FX */
#vignette {
position:fixed; inset:0; pointer-events:none; z-index:15;
border-radius:0; opacity:0;
box-shadow:inset 0 0 120px 60px #ff000088;
transition:opacity 0.05s;
}
#flash {
position:fixed; inset:0; pointer-events:none; z-index:14;
background:#fff; opacity:0; transition:opacity 0.08s;
}
#goldflash {
position:fixed; inset:0; pointer-events:none; z-index:14;
background:#ffe94e; opacity:0; transition:opacity 0.08s;
}

/* Floating text */
#floattext {
position:fixed; top:35%; left:50%; transform:translate(-50%,-50%);
pointer-events:none; z-index:16; text-align:center;
font-size:22px; color:#ffe94e; text-shadow:3px 3px #c47800;
opacity:0; transition:opacity 0.2s;
}

/* Hints */
#hints {
position:fixed; bottom:54px; left:50%; transform:translateX(-50%);
color:#fff6; font-size:7px; text-align:center; line-height:2;
pointer-events:none; z-index:10;
}

/* Combo */
#combo {
position:fixed; top:50%; right:24px;
color:#ffe94e; font-size:11px; text-align:right;
pointer-events:none; z-index:10; opacity:0;
text-shadow:2px 2px #c47800;
transition:opacity 0.3s;
}

/* Speed meter */
#speedmeter {
position:fixed; top:14px; left:50%; transform:translateX(-50%);
color:#ff6644; font-size:8px; opacity:0; pointer-events:none; z-index:10;
text-shadow:0 0 10px #ff664488;
transition:opacity 0.4s;
}
</style>

</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <div class="ui-box">SCORE<br><span class="val" id="scoreDisplay">0</span></div>
  <div class="ui-box" style="text-align:center;">
    ğŸŒ <span class="val" id="bananaDisplay">0</span>
    <br><div id="hearts">â¤ï¸â¤ï¸â¤ï¸</div>
  </div>
  <div class="ui-box" style="text-align:right;">BEST<br><span class="val" id="bestDisplay">0</span></div>
</div>

<div id="speedmeter">âš¡ FASTER!</div>

<div id="combo">ğŸŒ x<span id="comboCount">0</span></div>

<div id="powerups">
  <div class="pu-pill" id="pu-speed">âš¡ BOOST <div class="pu-bar"><div class="pu-fill" id="pf-speed" style="background:#ff6644;width:0%"></div></div></div>
  <div class="pu-pill" id="pu-shield">ğŸ›¡ï¸ SHIELD <div class="pu-bar"><div class="pu-fill" id="pf-shield" style="background:#44aaff;width:0%"></div></div></div>
  <div class="pu-pill" id="pu-magnet">ğŸ§² MAGNET <div class="pu-bar"><div class="pu-fill" id="pf-magnet" style="background:#ffe94e;width:0%"></div></div></div>
</div>

<div id="vignette"></div>
<div id="flash"></div>
<div id="goldflash"></div>
<div id="floattext"></div>

<div id="overlay">
  <div class="ov-title" id="ovTitle">ğŸŒ BANANA DASH 3D</div>
  <div class="ov-sub" id="ovSub">
    â† â†’ / A D â€” SWITCH LANES<br>
    SPACE / â†‘ â€” JUMP (DOUBLE JUMP!)<br><br>
    COLLECT POWERUPS:<br>
    âš¡ SPEED &nbsp; ğŸ›¡ï¸ SHIELD &nbsp; ğŸ§² MAGNET<br><br>
    WATCH OUT FOR ENEMIES!<br>
    3 LIVES â€” SHIELD SAVES YOU<br><br>
    <span class="blink">PRESS SPACE OR TAP TO START</span>
  </div>
</div>

<div id="hints">â† â†’ LANES &nbsp;|&nbsp; SPACE JUMP &nbsp;|&nbsp; DOUBLE JUMP OK</div>

<script src="https://unpkg.com/three@latest/build/three.min.js" 
        onload="if(typeof THREE !== 'undefined') initGame(); else alert('Game load failed - check connection!');" 
        onerror="alert('3D engine download failed. Refresh or try WiFi.');"></script>


'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  AUDIO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
function playTone(freq,type,dur,vol=0.22,freqEnd=null){
  try{
    const o=audioCtx.createOscillator(),g=audioCtx.createGain();
    o.connect(g);g.connect(audioCtx.destination);
    o.type=type; o.frequency.setValueAtTime(freq,audioCtx.currentTime);
    if(freqEnd) o.frequency.exponentialRampToValueAtTime(freqEnd,audioCtx.currentTime+dur);
    g.gain.setValueAtTime(vol,audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+dur);
    o.start(); o.stop(audioCtx.currentTime+dur);
  }catch(e){}
}
function sfxJump(dbl){ playTone(dbl?300:220,'square',0.12,0.18,dbl?650:440); }
function sfxBanana(){ playTone(523,'square',0.07,0.18); setTimeout(()=>playTone(784,'square',0.1,0.18),70); }
function sfxCombo(n){ playTone(400+n*80,'square',0.15,0.25,600+n*100); }
function sfxHit(){ playTone(220,'sawtooth',0.07,0.28,80); setTimeout(()=>playTone(110,'sawtooth',0.12,0.28),90); }
function sfxDie(){ [300,200,150,80].forEach((f,i)=>setTimeout(()=>playTone(f,'sawtooth',0.15,0.28),i*80)); }
function sfxStart(){ [261,329,392,523].forEach((f,i)=>setTimeout(()=>playTone(f,'square',0.1,0.18),i*75)); }
function sfxPowerup(type){
  if(type==='speed'){ playTone(400,'sawtooth',0.05,0.2); setTimeout(()=>playTone(600,'sawtooth',0.1,0.2),50); setTimeout(()=>playTone(800,'sawtooth',0.15,0.2),110); }
  if(type==='shield'){ playTone(300,'sine',0.08,0.2,600); setTimeout(()=>playTone(500,'sine',0.12,0.2),100); }
  if(type==='magnet'){ [350,450,550,650].forEach((f,i)=>setTimeout(()=>playTone(f,'triangle',0.1,0.15),i*60)); }
}
function sfxShieldPop(){ playTone(800,'sine',0.05,0.3,200); }
function sfxFaster(){ playTone(440,'square',0.08,0.2); setTimeout(()=>playTone(660,'square',0.12,0.2),90); }

let bgTimer=null,bgNodes=[];
function startBg(){
  stopBg();
  const notes=[261,329,392,523,392,329];let step=0;
  function tick(){
    try{
      const o=audioCtx.createOscillator(),g=audioCtx.createGain();
      o.connect(g);g.connect(audioCtx.destination);
      o.type='triangle'; o.frequency.value=notes[step++%notes.length];
      g.gain.setValueAtTime(0.045,audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.17);
      o.start();o.stop(audioCtx.currentTime+0.17);
      bgNodes.push(o);
    }catch(e){}
    bgTimer=setTimeout(tick,155);
  }tick();
}
function stopBg(){if(bgTimer)clearTimeout(bgTimer);bgNodes.forEach(n=>{try{n.stop();}catch(e){}});bgNodes=[];}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const renderer=new THREE.WebGLRenderer({canvas:document.getElementById('c'),antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight);
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
renderer.setClearColor(0x0d0520);

const scene=new THREE.Scene();
scene.fog=new THREE.FogExp2(0x0d0520,0.04);

const camera=new THREE.PerspectiveCamera(62,innerWidth/innerHeight,0.1,200);
camera.position.set(0,5,10);
camera.lookAt(0,1,0);

window.addEventListener('resize',()=>{
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
});

// â”€â”€ Lighting â”€â”€
scene.add(new THREE.AmbientLight(0x443366,0.9));
const sun=new THREE.DirectionalLight(0xffe494,2);
sun.position.set(5,14,5); sun.castShadow=true;
sun.shadow.mapSize.set(1024,1024);
sun.shadow.camera.left=-25;sun.shadow.camera.right=25;
sun.shadow.camera.top=25;sun.shadow.camera.bottom=-25;
scene.add(sun);
scene.add(Object.assign(new THREE.DirectionalLight(0x5533bb,0.5),{position:new THREE.Vector3(-5,3,-5)}));
const pointLight=new THREE.PointLight(0xffe94e,2,30);
pointLight.position.set(0,7,5); scene.add(pointLight);

// â”€â”€ Stars â”€â”€
const starGeo=new THREE.BufferGeometry();
const sp=new Float32Array(2400);
for(let i=0;i<2400;i+=3){sp[i]=(Math.random()-0.5)*300;sp[i+1]=8+Math.random()*70;sp[i+2]=(Math.random()-0.5)*300;}
starGeo.setAttribute('position',new THREE.BufferAttribute(sp,3));
scene.add(new THREE.Points(starGeo,new THREE.PointsMaterial({color:0xffffff,size:0.22})));

// â”€â”€ Moon â”€â”€
const moonMesh=new THREE.Mesh(new THREE.SphereGeometry(3.5,12,12),new THREE.MeshToonMaterial({color:0xfff8e0}));
moonMesh.position.set(-35,38,-90); scene.add(moonMesh);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LANE_W=2.2;
const LANES=[-LANE_W,0,LANE_W];
const TILE_LEN=6, TILE_COUNT=18;
const SPAWN_Z=-60;
const DESPAWN_Z=14;
const BASE_SPEED=10;
const PU_DURATION={speed:6,shield:10,magnet:8};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TRACK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const tileMats=[
  new THREE.MeshLambertMaterial({color:0x2a1850}),
  new THREE.MeshLambertMaterial({color:0x371e66}),
];
const tiles=[];
function makeTile(z){
  const idx=Math.abs(Math.floor(z/TILE_LEN))%2;
  const m=new THREE.Mesh(new THREE.BoxGeometry(LANE_W*3+0.6,0.4,TILE_LEN),tileMats[idx]);
  m.position.set(0,-0.2,z); m.receiveShadow=true; scene.add(m);
  // Edge glow
  const eg=new THREE.BoxGeometry(0.12,0.06,TILE_LEN);
  const em=new THREE.MeshBasicMaterial({color:0x7733cc});
  [-LANE_W*1.55,LANE_W*1.55].forEach(ex=>{
    const e=new THREE.Mesh(eg,em); e.position.set(ex,0.03,z); scene.add(e); m.userData.edges=m.userData.edges||[]; m.userData.edges.push(e);
  });
  // Lane dividers
  [LANE_W*-0.5,LANE_W*0.5].forEach(dx=>{
    const d=new THREE.Mesh(new THREE.BoxGeometry(0.05,0.05,TILE_LEN),new THREE.MeshBasicMaterial({color:0x4e2a80}));
    d.position.set(dx,0.03,z); scene.add(d);
  });
  return m;
}
for(let i=0;i<TILE_COUNT;i++) tiles.push(makeTile(-i*TILE_LEN));

// â”€â”€ Trees â”€â”€
const trunkM=new THREE.MeshLambertMaterial({color:0x3d2108});
const leafM=new THREE.MeshLambertMaterial({color:0x1a4a1a});
const sideTrees=[];
function makeTree(x,z){
  const g=new THREE.Group();
  g.add(Object.assign(new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.3,3,6),trunkM),{position:new THREE.Vector3(0,1.5,0)}));
  [4,5.6].forEach((y,i)=>{
    const c=new THREE.Mesh(new THREE.ConeGeometry(1.3-i*0.15,2.8-i*0.3,6),leafM);
    c.position.y=y; g.add(c);
  });
  g.position.set(x,0,z); g.rotation.y=Math.random()*Math.PI;
  scene.add(g); return g;
}
for(let z=4;z>-TILE_COUNT*TILE_LEN;z-=7){
  sideTrees.push(makeTree(-5.8,z)); sideTrees.push(makeTree(6,z));
}
// Temple pillars
const pillarM=new THREE.MeshLambertMaterial({color:0x3d2460});
for(let z=0;z>-120;z-=18){
  [-9,9].forEach(x=>{
    const p=new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.45,9,8),pillarM);
    p.position.set(x,4,z); scene.add(p);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MONKEY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function makeMonkey(){
  const g=new THREE.Group();
  const bodyM=new THREE.MeshToonMaterial({color:0xc97c30});
  const darkM=new THREE.MeshToonMaterial({color:0x7a4a15});
  const faceM=new THREE.MeshToonMaterial({color:0xf5c89a});
  const eyeM=new THREE.MeshToonMaterial({color:0x111111});
  const whiteM=new THREE.MeshToonMaterial({color:0xffffff});

  const body=new THREE.Mesh(new THREE.BoxGeometry(0.72,0.82,0.52),bodyM);
  body.position.y=0.41; g.add(body);
  const head=new THREE.Mesh(new THREE.BoxGeometry(0.66,0.62,0.56),bodyM);
  head.position.y=1.16; g.add(head);
  const face=new THREE.Mesh(new THREE.BoxGeometry(0.46,0.4,0.1),faceM);
  face.position.set(0,1.09,0.31); g.add(face);
  [-0.13,0.13].forEach(ex=>{
    const ew=new THREE.Mesh(new THREE.BoxGeometry(0.11,0.11,0.06),whiteM);
    ew.position.set(ex,1.19,0.33); g.add(ew);
    const ep=new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,0.06),eyeM);
    ep.position.set(ex,1.19,0.36); g.add(ep);
  });
  [-0.4,0.4].forEach(ex=>{
    const ear=new THREE.Mesh(new THREE.BoxGeometry(0.19,0.23,0.19),bodyM);
    ear.position.set(ex,1.16,0); g.add(ear);
    const ei=new THREE.Mesh(new THREE.BoxGeometry(0.11,0.15,0.11),faceM);
    ei.position.set(ex,1.16,0.06); g.add(ei);
  });
  const legL=new THREE.Mesh(new THREE.BoxGeometry(0.23,0.52,0.23),darkM); legL.position.set(-0.21,-0.3,0); g.add(legL);
  const legR=new THREE.Mesh(new THREE.BoxGeometry(0.23,0.52,0.23),darkM); legR.position.set(0.21,-0.3,0); g.add(legR);
  const armL=new THREE.Mesh(new THREE.BoxGeometry(0.19,0.52,0.19),bodyM); armL.position.set(-0.49,0.36,0); g.add(armL);
  const armR=new THREE.Mesh(new THREE.BoxGeometry(0.19,0.52,0.19),bodyM); armR.position.set(0.49,0.36,0); g.add(armR);
  const tail=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.04,0.85,6),darkM);
  tail.position.set(0.12,0.14,-0.37); tail.rotation.x=0.85; tail.rotation.z=0.5; g.add(tail);

  g.traverse(c=>{if(c.isMesh)c.castShadow=true;});
  g._legL=legL; g._legR=legR; g._armL=armL; g._armR=armR; g._body=body; g._head=head;
  return g;
}
const monkey=makeMonkey();
monkey.position.set(0,0.55,4); scene.add(monkey);

// â”€â”€ Shield bubble â”€â”€
const shieldMesh=new THREE.Mesh(
  new THREE.SphereGeometry(1.0,16,16),
  new THREE.MeshBasicMaterial({color:0x44aaff,transparent:true,opacity:0.28,wireframe:false,side:THREE.DoubleSide})
);
shieldMesh.visible=false; monkey.add(shieldMesh);

// â”€â”€ Magnet field ring â”€â”€
const magnetRing=new THREE.Mesh(
  new THREE.TorusGeometry(1.8,0.06,8,32),
  new THREE.MeshBasicMaterial({color:0xffe94e,transparent:true,opacity:0.35})
);
magnetRing.rotation.x=Math.PI/2; magnetRing.visible=false; monkey.add(magnetRing);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MATERIALS POOL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const obsMats=[
  new THREE.MeshToonMaterial({color:0xe03a5a}),
  new THREE.MeshToonMaterial({color:0xff6644}),
  new THREE.MeshToonMaterial({color:0x4488ff}),
];
const bananaMat=new THREE.MeshToonMaterial({color:0xffe94e,emissive:0xaa7700,emissiveIntensity:0.4});
const enemyBodyM=new THREE.MeshToonMaterial({color:0xcc2244});
const enemyEyeM=new THREE.MeshToonMaterial({color:0xff0000,emissive:0xff0000,emissiveIntensity:0.8});
const puMats={
  speed:new THREE.MeshToonMaterial({color:0xff6644,emissive:0xaa3300,emissiveIntensity:0.5}),
  shield:new THREE.MeshToonMaterial({color:0x44aaff,emissive:0x002255,emissiveIntensity:0.5}),
  magnet:new THREE.MeshToonMaterial({color:0xffe94e,emissive:0xaa7700,emissiveIntensity:0.5}),
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FACTORY: OBSTACLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function makeObstacle(){
  const laneIdx=Math.floor(Math.random()*3);
  const roll=Math.random();
  let w=0.85,h,d=0.72;
  if(roll<0.45) h=1.9;
  else if(roll<0.75){h=0.65;w=1.7;}
  else h=1.1;
  const mat=obsMats[Math.floor(Math.random()*obsMats.length)];
  const mesh=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),mat);
  mesh.position.set(LANES[laneIdx],h/2,SPAWN_Z);
  mesh.castShadow=true;
  const top=new THREE.Mesh(new THREE.BoxGeometry(w+0.06,0.1,d+0.06),
    new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.25}));
  top.position.y=h/2+0.05; mesh.add(top);
  scene.add(mesh);
  return {mesh,laneIdx,w,h,type:'obstacle'};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FACTORY: ENEMY (gorilla or bird)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function makeEnemy(){
  const isGorilla=Math.random()<0.5;
  const g=new THREE.Group();
  if(isGorilla){
    // Gorilla: big low-poly ape
    const body=new THREE.Mesh(new THREE.BoxGeometry(0.9,1.1,0.7),enemyBodyM); body.position.y=0.55; g.add(body);
    const head=new THREE.Mesh(new THREE.BoxGeometry(0.7,0.6,0.6),enemyBodyM); head.position.y=1.25; g.add(head);
    [-0.25,0.25].forEach(ex=>{
      const e=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.08,0.05),enemyEyeM); e.position.set(ex,1.3,0.32); g.add(e);
    });
    // Arms down (gorilla walk)
    [-0.6,0.6].forEach(ax=>{
      const arm=new THREE.Mesh(new THREE.BoxGeometry(0.22,0.7,0.22),enemyBodyM); arm.position.set(ax,0.2,0); g.add(arm);
    });
    g._isGorilla=true;
    // Gorilla patrols lanes
    const startLane=Math.floor(Math.random()*3);
    g.position.set(LANES[startLane],0.55,SPAWN_Z);
    g._lane=startLane; g._patrolTimer=1.5+Math.random()*1.5;
  } else {
    // Bird: angular flying enemy
    const body=new THREE.Mesh(new THREE.ConeGeometry(0.3,1.0,4),enemyBodyM);
    body.rotation.z=Math.PI/2; body.position.set(0,0,0); g.add(body);
    [-1,1].forEach(s=>{
      const wing=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.5,0.7),enemyBodyM);
      wing.position.set(0,s*0.35,0); g.add(wing);
    });
    const eye=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.08,0.08),enemyEyeM);
    eye.position.set(0.4,0.1,0); g.add(eye);
    g._isGorilla=false;
    const startLane=Math.floor(Math.random()*3);
    g.position.set(LANES[startLane],1.2,SPAWN_Z);
    g._lane=startLane; g._patrolTimer=0;
  }
  g.traverse(c=>{if(c.isMesh)c.castShadow=true;});
  scene.add(g);
  return {mesh:g,type:'enemy',isGorilla,laneIdx:g._lane};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FACTORY: BANANA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function makeBanana(z,forceLane){
  const laneIdx=forceLane!==undefined?forceLane:Math.floor(Math.random()*3);
  const g=new THREE.Group();
  const body=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.56,8),bananaMat);
  body.rotation.z=0.5; g.add(body);
  const glow=new THREE.Mesh(new THREE.SphereGeometry(0.38,8,8),
    new THREE.MeshBasicMaterial({color:0xffe94e,transparent:true,opacity:0.14}));
  g.add(glow);
  g.position.set(LANES[laneIdx],0.9,z===undefined?SPAWN_Z:z);
  scene.add(g);
  return {mesh:g,laneIdx,taken:false,type:'banana'};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FACTORY: POWERUP TOKEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PU_TYPES=['speed','shield','magnet'];
const PU_SYMBOLS={speed:'âš¡',shield:'ğŸ›¡ï¸',magnet:'ğŸ§²'};
function makePowerup(){
  const puType=PU_TYPES[Math.floor(Math.random()*3)];
  const laneIdx=Math.floor(Math.random()*3);
  const g=new THREE.Group();
  const inner=new THREE.Mesh(new THREE.IcosahedronGeometry(0.38,0),puMats[puType]);
  g.add(inner);
  const ring=new THREE.Mesh(new THREE.TorusGeometry(0.55,0.06,8,24),
    new THREE.MeshBasicMaterial({color:puType==='speed'?0xff6644:puType==='shield'?0x44aaff:0xffe94e,transparent:true,opacity:0.6}));
  ring.rotation.x=Math.PI/2; g.add(ring);
  g.position.set(LANES[laneIdx],1.1,SPAWN_Z);
  g._inner=inner; g._ring=ring;
  scene.add(g);
  return {mesh:g,puType,laneIdx,taken:false,type:'powerup'};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PARTICLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const particlePool=[];
function spawnParticles(pos,color,n=10,spread=4){
  for(let i=0;i<n;i++){
    let p=particlePool.find(x=>x.life<=0);
    if(!p){
      const m=new THREE.Mesh(new THREE.BoxGeometry(0.14,0.14,0.14),
        new THREE.MeshBasicMaterial({color,transparent:true}));
      scene.add(m); p={mesh:m,vx:0,vy:0,vz:0,life:0,maxLife:0};
      particlePool.push(p);
    }
    p.mesh.material.color.setHex(color);
    p.mesh.position.copy(pos);
    p.vx=(Math.random()-0.5)*spread; p.vy=2+Math.random()*4; p.vz=(Math.random()-0.5)*spread;
    p.life=1; p.maxLife=1;
    p.mesh.visible=true;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SCREEN FX HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let shakeAmount=0,shakeFade=0;
const cameraBase=new THREE.Vector3(0,5,10);

function doShake(amount=0.4,dur=12){ shakeAmount=amount; shakeFade=dur; }

let vigTimer=null;
function doVignette(color='red',dur=350){
  const el=document.getElementById('vignette');
  el.style.boxShadow=color==='red'?'inset 0 0 140px 70px #ff000088':'inset 0 0 140px 70px #44aaff88';
  el.style.opacity='1';
  clearTimeout(vigTimer); vigTimer=setTimeout(()=>el.style.opacity='0',dur);
}

let flashTimer=null;
function doFlash(gold=false,dur=80){
  const el=document.getElementById(gold?'goldflash':'flash');
  el.style.opacity='0.55'; clearTimeout(flashTimer);
  flashTimer=setTimeout(()=>el.style.opacity='0',dur);
}

let floatTimer=null;
function showFloatText(txt,color='#ffe94e'){
  const el=document.getElementById('floattext');
  el.textContent=txt; el.style.color=color; el.style.opacity='1';
  el.style.transform='translate(-50%,-50%) scale(1.3)';
  clearTimeout(floatTimer);
  setTimeout(()=>{el.style.transition='opacity 0.4s, transform 0.4s'; el.style.transform='translate(-50%,-80%) scale(1)';},50);
  floatTimer=setTimeout(()=>el.style.opacity='0',700);
}

let speedTextTimer=null;
function showFaster(){
  const el=document.getElementById('speedmeter');
  el.style.opacity='1'; sfxFaster();
  clearTimeout(speedTextTimer); speedTextTimer=setTimeout(()=>el.style.opacity='0',900);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let state='idle';
let score=0,best=0,bananas=0,lives=3;
let speed=BASE_SPEED,frameCount=0;
let lane=1,targetX=LANES[1];
let monkeyY=0.55,vy=0,onGround=true,jumps=0;
let hitCooldown=0;
let comboCount=0,lastSpeedMilestone=0;
let slowMo=1; // for death slow-motion

// Powerup state
const pu={
  speed:{active:false,timer:0},
  shield:{active:false,timer:0},
  magnet:{active:false,timer:0},
};

// Dynamic lists
const obstacles=[], enemies=[], bananaItems=[], powerups=[], particles=particlePool;

// Tween state
let leanTween=0; // target lean for lane switch
let squashY=1,squashXZ=1; // for jump squash/stretch
let armRaise=0; // for banana celebration

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HUD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateHUD(){
  document.getElementById('scoreDisplay').textContent=Math.floor(score);
  document.getElementById('bananaDisplay').textContent=bananas;
  document.getElementById('bestDisplay').textContent=Math.floor(best);
  document.getElementById('hearts').textContent='â¤ï¸'.repeat(Math.max(0,lives))+'ğŸ–¤'.repeat(Math.max(0,3-lives));
  // Combo
  const comboEl=document.getElementById('combo');
  if(comboCount>=2){ comboEl.style.opacity='1'; document.getElementById('comboCount').textContent=comboCount; }
  else comboEl.style.opacity='0';
  // Powerup bars
  ['speed','shield','magnet'].forEach(t=>{
    const pill=document.getElementById('pu-'+t);
    const fill=document.getElementById('pf-'+t);
    if(pu[t].active){
      pill.classList.add('active');
      fill.style.width=(pu[t].timer/PU_DURATION[t]*100)+'%';
    } else {
      pill.classList.remove('active');
      fill.style.width='0%';
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INPUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('keydown',e=>{
  if(e.code==='Space'||e.code==='ArrowUp'){e.preventDefault(); onPressAction();}
  if(e.code==='ArrowLeft'||e.code==='KeyA'){e.preventDefault(); changeLane(-1);}
  if(e.code==='ArrowRight'||e.code==='KeyD'){e.preventDefault(); changeLane(1);}
});
let tx0=null,ty0=null;
document.addEventListener('touchstart',e=>{tx0=e.touches[0].clientX;ty0=e.touches[0].clientY;},{passive:true});
document.addEventListener('touchend',e=>{
  if(tx0===null)return;
  const dx=e.changedTouches[0].clientX-tx0,dy=e.changedTouches[0].clientY-ty0;
  if(Math.abs(dy)>Math.abs(dx)&&dy<-25) onPressAction();
  else if(Math.abs(dx)>25){ if(dx<0)changeLane(-1); else changeLane(1); }
  else onPressAction();
  tx0=null;ty0=null;
},{passive:true});

function onPressAction(){
  if(state==='idle'||state==='dead'){ startGame(); return; }
  if(state==='playing') handleJump();
}
function changeLane(dir){
  if(state!=='playing') return;
  const newLane=Math.max(0,Math.min(2,lane+dir));
  if(newLane===lane) return;
  lane=newLane; targetX=LANES[lane];
  leanTween=dir*0.35;
}
function handleJump(){
  if(jumps>=2) return;
  sfxJump(jumps===1);
  vy=jumps===0?10:8;
  onGround=false; jumps++;
  // Squash on launch
  squashY=1.3; squashXZ=0.75;
  if(jumps===2) spawnParticles(monkey.position.clone().add(new THREE.Vector3(0,0.5,0)),0xaa66ff,10,3);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME CONTROL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startGame(){
  audioCtx.resume();
  clearGame();
  state='playing'; slowMo=1;
  document.getElementById('overlay').classList.add('hidden');
  sfxStart(); setTimeout(startBg,370);
}

function clearGame(){
  const clear=arr=>{arr.forEach(o=>{if(o.mesh)scene.remove(o.mesh);});arr.length=0;};
  clear(obstacles); clear(enemies); clear(bananaItems); clear(powerups);
  particlePool.forEach(p=>{p.life=0;p.mesh.visible=false;});
  score=0;bananas=0;lives=3;speed=BASE_SPEED;frameCount=0;
  lane=1;targetX=LANES[1]; monkeyY=0.55; vy=0; onGround=true; jumps=0;
  hitCooldown=0; comboCount=0; lastSpeedMilestone=0; slowMo=1;
  leanTween=0; squashY=1; squashXZ=1; armRaise=0;
  ['speed','shield','magnet'].forEach(t=>{pu[t].active=false;pu[t].timer=0;});
  shieldMesh.visible=false; magnetRing.visible=false;
  monkey.visible=true; monkey.position.set(0,0.55,4); monkey.rotation.set(0,0,0);
  updateHUD();
}

function triggerDeath(){
  if(state==='dying'||state==='dead') return;
  state='dying'; slowMo=1; stopBg(); sfxDie();
  doShake(0.8,30); doVignette('red',1200);
  // Spin-out tween
  let spinT=0;
  const spin=setInterval(()=>{
    slowMo=Math.max(0.15,slowMo-0.04);
    spinT+=0.16;
    monkey.rotation.z+=0.18;
    monkey.position.y+=0.05;
    if(spinT>1.5){
      clearInterval(spin);
      if(score>best)best=score;
      state='dead';
      document.getElementById('ovTitle').textContent='GAME OVER ğŸ’';
      document.getElementById('ovSub').innerHTML=`SCORE: ${Math.floor(score)} &nbsp;|&nbsp; ğŸŒ ${bananas}<br>BEST: ${Math.floor(best)}<br><br><span class="blink">PRESS SPACE OR TAP</span>`;
      document.getElementById('overlay').classList.remove('hidden');
      updateHUD();
    }
  },30);
}

function loseLife(){
  if(hitCooldown>0) return;
  // Shield absorbs hit
  if(pu.shield.active){
    sfxShieldPop();
    pu.shield.active=false; pu.shield.timer=0;
    shieldMesh.visible=false;
    doFlash(false,100); doShake(0.25,8);
    showFloatText('ğŸ›¡ï¸ BLOCKED!','#44aaff');
    hitCooldown=60; updateHUD(); return;
  }
  lives--; sfxHit();
  hitCooldown=90;
  doShake(0.5,18); doVignette('red',500); doFlash(false,80);
  spawnParticles(monkey.position.clone(),0xff3366,16,5);
  updateHUD();
  if(lives<=0) triggerDeath();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPAWN TIMERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let obsTimer=0,enemyTimer=0,bananaTimer=0,puTimer=0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const clock=new THREE.Clock();
const GRAVITY=22;

function update(rawDt){
  const dt=Math.min(rawDt,0.05)*slowMo;
  frameCount++;

  const isPlaying=state==='playing';
  const isAlive=state==='playing'||state==='dying';

  if(isPlaying){
    score+=dt*35;
    const newSpeed=BASE_SPEED + score/350;
    // Speed milestone every +3 units
    if(Math.floor(newSpeed)>Math.floor(speed) && Math.floor(newSpeed)>lastSpeedMilestone){
      lastSpeedMilestone=Math.floor(newSpeed); showFaster();
    }
    speed=newSpeed + (pu.speed.active?5:0);
  }

  // â”€â”€ Powerup timers â”€â”€
  if(isPlaying){
    ['speed','shield','magnet'].forEach(t=>{
      if(pu[t].active){ pu[t].timer-=dt; if(pu[t].timer<=0){pu[t].active=false;pu[t].timer=0;} }
    });
    shieldMesh.visible=pu.shield.active;
    magnetRing.visible=pu.magnet.active;
    if(pu.shield.active){ shieldMesh.material.opacity=0.2+Math.sin(clock.getElapsedTime()*8)*0.1; shieldMesh.rotation.y+=dt*2; }
    if(pu.magnet.active){ magnetRing.rotation.z+=dt*3; }
    if(pu.speed.active) spawnParticles(monkey.position.clone().add(new THREE.Vector3(0,0.5,0)),0xff6644,1,2);
  }

  // â”€â”€ Track scroll â”€â”€
  const scrollZ=speed*dt;
  tiles.forEach(t=>{
    t.position.z+=scrollZ;
    if(t.position.z>TILE_LEN*2) t.position.z-=TILE_COUNT*TILE_LEN;
  });
  sideTrees.forEach(t=>{
    t.position.z+=scrollZ*0.98;
    if(t.position.z>12) t.position.z-=TILE_COUNT*TILE_LEN;
  });

  // â”€â”€ Monkey horizontal (smooth lerp with overshoot) â”€â”€
  const lerpT=Math.min(1,dt*16);
  monkey.position.x+=(targetX-monkey.position.x)*lerpT;
  // Lean tween (overshoot and recover)
  leanTween*=Math.pow(0.88,dt*60);
  monkey.rotation.z=leanTween+(targetX-monkey.position.x)*0.12;

  // â”€â”€ Monkey vertical â”€â”€
  if(isAlive&&state!=='dying'){
    monkeyY+=vy*dt;
    vy-=GRAVITY*dt;
    if(monkeyY<=0.55){
      if(!onGround&&vy<-3){ squashY=0.7; squashXZ=1.3; } // land squash
      monkeyY=0.55; vy=0; onGround=true; jumps=0;
    } else onGround=false;
  }
  if(state!=='dying') monkey.position.y=monkeyY;

  // â”€â”€ Squash & stretch ease â”€â”€
  squashY+=(1-squashY)*Math.min(1,dt*12);
  squashXZ+=(1-squashXZ)*Math.min(1,dt*12);
  monkey.scale.set(squashXZ,squashY,squashXZ);

  // â”€â”€ Arm raise (banana celebration) â”€â”€
  armRaise*=Math.pow(0.85,dt*60);
  monkey._armL.rotation.x=-armRaise; monkey._armR.rotation.x=-armRaise;

  // â”€â”€ Leg/arm run animation â”€â”€
  if(onGround&&isPlaying){
    const t=clock.getElapsedTime();
    monkey._legL.rotation.x=Math.sin(t*speed*0.9)*0.55;
    monkey._legR.rotation.x=-Math.sin(t*speed*0.9)*0.55;
    if(armRaise<0.1){
      monkey._armL.rotation.x=-Math.sin(t*speed*0.9)*0.45;
      monkey._armR.rotation.x=Math.sin(t*speed*0.9)*0.45;
    }
  } else if(!onGround){
    monkey._legL.rotation.x=0.35; monkey._legR.rotation.x=0.35;
    if(armRaise<0.1){ monkey._armL.rotation.x=-0.6; monkey._armR.rotation.x=-0.6; }
  }

  // â”€â”€ Hit cooldown â”€â”€
  if(hitCooldown>0){
    hitCooldown--;
    monkey.visible=Math.floor(hitCooldown/6)%2===0;
  } else monkey.visible=true;

  // â”€â”€ Camera shake â”€â”€
  if(shakeFade>0){
    shakeFade--; const s=shakeAmount*(shakeFade/12);
    camera.position.x=cameraBase.x+(Math.random()-0.5)*s;
    camera.position.y=cameraBase.y+(Math.random()-0.5)*s*0.5;
  } else {
    camera.position.x+=(cameraBase.x+monkey.position.x*0.14-camera.position.x)*dt*6;
    camera.position.y=cameraBase.y+(onGround?0:0.6);
  }
  camera.lookAt(monkey.position.x*0.25,1.5,0);
  pointLight.position.x=monkey.position.x;
  pointLight.intensity=2+(pu.speed.active?1.5:0)+(pu.magnet.active?0.8:0);

  if(!isPlaying) return;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  SPAWN
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  obsTimer+=dt;
  enemyTimer+=dt;
  bananaTimer+=dt;
  puTimer+=dt;

  const obsInterval=Math.max(0.55,1.4-score/4000);
  const enemyInterval=Math.max(2.5,5-score/1500);
  const banInterval=0.75;
  const puInterval=Math.max(8,18-score/500);

  if(obsTimer>obsInterval){ obstacles.push(makeObstacle()); obsTimer=0; }
  if(enemyTimer>enemyInterval){ enemies.push(makeEnemy()); enemyTimer=0; }
  if(bananaTimer>banInterval){ bananaItems.push(makeBanana()); bananaTimer=0; }
  if(puTimer>puInterval){ powerups.push(makePowerup()); puTimer=0; }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  MOVE & COLLIDE: OBSTACLES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  for(let i=obstacles.length-1;i>=0;i--){
    const o=obstacles[i];
    o.mesh.position.z+=scrollZ;
    if(o.mesh.position.z>DESPAWN_Z){scene.remove(o.mesh);obstacles.splice(i,1);continue;}
    if(hitCooldown===0){
      const dx=Math.abs(monkey.position.x-o.mesh.position.x);
      const dz=Math.abs(monkey.position.z-o.mesh.position.z);
      if(dx<0.38+o.w*0.42&&dz<0.75&&monkeyY<o.h+0.15){loseLife();break;}
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  MOVE & COLLIDE: ENEMIES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    const t=clock.getElapsedTime();
    e.mesh.position.z+=scrollZ*(e.isGorilla?1:1.6); // birds faster

    if(e.mesh.position.z>DESPAWN_Z){scene.remove(e.mesh);enemies.splice(i,1);continue;}

    if(e.isGorilla){
      // Patrol lanes on a timer
      e.mesh._patrolTimer=(e.mesh._patrolTimer||1.5)-dt;
      if(e.mesh._patrolTimer<=0){
        // Pick adjacent lane
        const choices=[];
        if(e.laneIdx>0)choices.push(e.laneIdx-1);
        if(e.laneIdx<2)choices.push(e.laneIdx+1);
        e.laneIdx=choices[Math.floor(Math.random()*choices.length)];
        e.mesh.position.x+=(LANES[e.laneIdx]-e.mesh.position.x);
        e.mesh._patrolTimer=1.2+Math.random()*1.2;
      }
      // Bounce animation
      e.mesh.position.y=0.55+Math.abs(Math.sin(t*6))*0.18;
      e.mesh.rotation.y=Math.sin(t*4)*0.2;
    } else {
      // Bird: sine weave between lanes
      e.mesh.position.y=1.2+Math.sin(t*5+i)*0.4;
      e.mesh.rotation.z=Math.sin(t*8)*0.15;
    }

    if(hitCooldown===0){
      const dx=Math.abs(monkey.position.x-e.mesh.position.x);
      const dz=Math.abs(monkey.position.z-e.mesh.position.z);
      const dy=Math.abs(monkeyY-e.mesh.position.y);
      if(dx<0.7&&dz<0.8&&dy<0.9){loseLife();break;}
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  MOVE & COLLIDE: BANANAS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const magnetRange=3.5;
  for(let i=bananaItems.length-1;i>=0;i--){
    const b=bananaItems[i];
    b.mesh.position.z+=scrollZ;
    b.mesh.rotation.y+=dt*3;

    // Magnet pull
    if(pu.magnet.active&&!b.taken){
      const dx=monkey.position.x-b.mesh.position.x;
      const dz=monkey.position.z-b.mesh.position.z;
      const dist=Math.sqrt(dx*dx+dz*dz);
      if(dist<magnetRange){
        b.mesh.position.x+=dx*dt*8;
        b.mesh.position.z+=dz*dt*8;
        b.mesh.position.y+=(monkeyY-b.mesh.position.y)*dt*8;
      }
    }

    if(b.mesh.position.z>DESPAWN_Z){scene.remove(b.mesh);bananaItems.splice(i,1);continue;}
    if(!b.taken){
      const dx=Math.abs(monkey.position.x-b.mesh.position.x);
      const dz=Math.abs(monkey.position.z-b.mesh.position.z);
      const dy=Math.abs(monkeyY-b.mesh.position.y);
      if(dx<0.85&&dz<0.85&&dy<1){
        b.taken=true; bananas++; score+=50;
        comboCount++;
        sfxBanana();
        doFlash(true,60);
        armRaise=1.1; // arms up!
        spawnParticles(b.mesh.position.clone(),0xffe94e,14,4);
        if(comboCount>=3){ showFloatText(`ğŸŒ COMBO x${comboCount}!`,'#ffe94e'); sfxCombo(Math.min(comboCount,6)); }
        else showFloatText('+50','#ffe94e');
        scene.remove(b.mesh); bananaItems.splice(i,1);
        updateHUD(); continue;
      } else comboCount=0;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  MOVE & COLLIDE: POWERUPS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  for(let i=powerups.length-1;i>=0;i--){
    const p=powerups[i];
    p.mesh.position.z+=scrollZ;
    p.mesh._inner.rotation.y+=dt*3;
    p.mesh._ring.rotation.z+=dt*2;
    p.mesh.position.y=1.1+Math.sin(clock.getElapsedTime()*3+i)*0.18;
    if(p.mesh.position.z>DESPAWN_Z){scene.remove(p.mesh);powerups.splice(i,1);continue;}
    if(!p.taken){
      const dx=Math.abs(monkey.position.x-p.mesh.position.x);
      const dz=Math.abs(monkey.position.z-p.mesh.position.z);
      const dy=Math.abs(monkeyY-p.mesh.position.y);
      if(dx<1&&dz<1&&dy<1.1){
        p.taken=true;
        pu[p.puType].active=true; pu[p.puType].timer=PU_DURATION[p.puType];
        sfxPowerup(p.puType);
        spawnParticles(p.mesh.position.clone(),
          p.puType==='speed'?0xff6644:p.puType==='shield'?0x44aaff:0xffe94e,18,5);
        doFlash(p.puType!=='shield',100);
        showFloatText(PU_SYMBOLS[p.puType]+' '+p.puType.toUpperCase()+'!',
          p.puType==='speed'?'#ff6644':p.puType==='shield'?'#44aaff':'#ffe94e');
        scene.remove(p.mesh); powerups.splice(i,1);
        updateHUD(); continue;
      }
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  PARTICLES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  particlePool.forEach(p=>{
    if(p.life<=0){p.mesh.visible=false;return;}
    p.mesh.visible=true;
    p.mesh.position.x+=p.vx*dt;
    p.mesh.position.y+=p.vy*dt;
    p.mesh.position.z+=p.vz*dt;
    p.vy-=14*dt; p.life-=dt*1.8;
    p.mesh.material.opacity=Math.max(0,p.life);
  });

  updateHUD();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const idleClock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const rawDt=Math.min(clock.getDelta(),0.05);
  update(rawDt);
  // Idle monkey bob
  if(state==='idle') monkey.position.y=0.55+Math.sin(idleClock.getElapsedTime()*2)*0.09;
  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>